---
title: NodeJS垃圾回收
description: NodeJS垃圾回收
date: 2024-01-04
categories: ["NodeJS", "垃圾回收"]
tags: ["NodeJS", "垃圾回收"]
---

# 1 垃圾回收

## 1.1 对象分配

1. node在单个进程上有内存限制 

   在32位系统限制 0.7GB

   64位系统限制 1.4G

---

代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8限制.

在node启东市传递参数可以调整内存限制大小

```bash
node --max-old-space-size=1700 test.js	// 单位是MB

node --max-new-space-size=1700 test.js	// 单位是KB
```



## 1.2 垃圾回收机制

[Node.js内存管理和V8垃圾回收机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/72380507)

[NodeJS垃圾回收算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/44099214)

[超详细的node垃圾回收机制 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903859089866760)

---

nodejs的内存分为新生代和老生代，老生代内存是由启动参数`--max-old-space-size`指定的，有默认值。新生代内存是由启动参数`--max-new-space-size`指定。

### 1.2.1 新生代内存垃圾回收：Scavenge算法

将内存一分为二，分成`from内存`和`to内存`，分配的内存总是存在`from内存`中。当进行gc的时候会检查`from内存`中存活的对象，然后复制到`to内存`中，然后`to内存`变成`from内存`，原本的`from内存`清空。

这个算法是空间换时间，缺点就是内存永远只能使用一半。新生代内存一般是临时new出来的对象，不是栈上的数据，但是生命周期又很短，比较适合用这种垃圾回收方式。

如果一个对象生命周期变长，会{{< highlight >}}晋升{{< /highlight >}}到老生代内存。晋升的条件有两个：

1. 是否经历过Scavenge算法
2. to内存超过限制

![nodejs新生代内存垃圾回收](/note/nodejs新生代内存垃圾回收.jpg)

### 1.2.2 老生代内存垃圾回收：Mark-Sweep & Mark-Compact 

老生代内存就不适合用新生代内存的垃圾回收方式了，原因：

1. 老生代活跃的对象较多，复制效率慢
2. 只能使用一半的内存

---

Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。这种方式最大的问题就是内存会出现不连续的状态，即内存碎片。

Mark-Compact是改进版，在检查死亡对象的时候，会将这些对象往一端移动，移动完之后，将一端得内存回收，就能减少内存碎片

![nodejs老生代内存垃圾回收](/note/nodejs老生代内存垃圾回收.jpg)

### 1.2.3 步进垃圾回收

为了避免出现JavaScrip应用逻辑和垃圾回收器看到的情况不一致（即正在使用内存时内存被回收了等竞争行为），需要将主线程暂停，然后执行垃圾回收，再恢复主线程，这种行为称为{{< highlight >}}全停顿（stop the world）{{< /highlight >}}。

但是stw停顿时间可能会比较长，影响主线程执行，因此为了降低停顿时间，将原本一口气停顿得动作改为{{< highlight >}}增量标记（incremental marking）{{< /highlight >}}，也就是拆成很多个“步进”，每次步进就让主线程执行一会，直到标记完之后再清理内存。

# 2 内存泄露

内存泄漏的实质是应该回收的对象没有被回收，称为老生代（分代回收）中的对象

造成内存泄漏的原因主要是对象被某个对象A引用了（可能是map，array等容器或键值对等），但是对象A又被对象B引用了，导致对象A不会被gc标记，也就导致该释放得内存不会被标记。

## 2.1 内存泄漏排查

快照，启动进程的时候抓一份快照，然后加载数据正常跑一段时间，关闭服务器之前再抓一份快照。

