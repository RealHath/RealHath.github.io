---
author : "RealHath"
title: C++ 核心4-2 友元、运算符重载
tags: ["C++", "编程学习"]
categories: ["C++"]
date: "2020-12-14 19:48:55"
toc: true
---



## 友元
私有属性能让类外一些函数或者类访问，用到友元

友元关键字{{< highlight >}}friend{{< /highlight >}}

友元三种实现
- 全局函数做友元
```cpp
class Person
{
    friend void test();     //全局函数做友元
};
```

- 类做友元
```cpp
class Person
{
    friend class People;     //类做友元
};
```

- 成员函数做友元
```cpp
class Person
{
    friend void People::test();     //别的类的成员函数做友元
};
```

## 运算符重载
{{< highlight >}}运算符重载不会影响运算符本身的功能.{{< /highlight >}}

==注意链式编程思想：cout << a << b << endl;  a = b = c;重载的时候注意返回值类型==

考虑到矩阵的不同的运算，使用运算符重载后会和数字计算一样，提高代码可读性。

注意以下几点：

1. 除了‘=’运算符以外，其他的运算符重载最好设计成为友元函数。

2. 把‘=’运算符重载为类成员变量，并且将返回值设计成为该类的引用。

3. 一定要自定义一个拷贝构造函数，这样在重载运算符返回对象副本的时候，编译器会自动调用拷贝构造函数，否则会出现结果错误。

4. 友元关系不会被派生类继承。

5. '::'、'?:'、'.*'、'.'等运算符是不能够被重载的。

### 加号运算符重载 +
> https://www.cnblogs.com/anSn/p/11611257.html

```cpp
返回值类型 operator+ (形参列表)
{
    
}
```

### 左移运算符重载 <<
如果类成员函数是私有，可以把左移重载作为友元放在类里

```cpp
ostream &operator<<(ostream &cout, Person &p)
{
    cout << " " << p.name;
    reutrn cout;
}
```

### 递增运算符重载 ++ / --
//返回引用为了一直对一个数自加

//比如cout << ++(++a) << endl;

//cout << a;
```cpp
//在类中重载
//重载前置++运算符
数据类型 &opetator++()
{
    num++;
    return *this;
}
```
```cpp
//在类中重载
//重载后置++运算符
//形参列表用一个int占位符区分，不同引用
数据类型 opetator++(int)
{
    数据类型 temp = *this;
    num++;
    return temp;
}
```

### 赋值运算符重载 =
返回对象本身，可以做到连等操作：p1 = p2 = p3;

深拷贝逻辑：先释放原来对象的指针指向的堆区内存，然后重新创建，在指向。

{{< highlight >}}常用于深拷贝{{< /highlight >}}
```cpp
Person &operator=(Person &p)
{
    { 深拷贝逻辑 }
    
    return *this;
}
```

### 关系运算符重载 > / < / == / !=
```cpp
bool operator==(Person &p)
{
    if(判断)
        return true;
    else
        return false;
}
```

### 函数调用运算符重载 ()
重载后使用方式很像函数调用，因此称为**仿函数**

灵活，没有固定写法
```cpp
void operator() ()
{
    
}
```