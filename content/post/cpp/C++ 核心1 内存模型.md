---
author : "RealHath"
title: C++ 核心1 内存模型
tags: ["C++", "编程学习"]
categories: ["C++"]
date: "2020-11-14 15:12:55"
toc: true
---


## 内存四区
> https://blog.csdn.net/helloyurenjie/article/details/79795059

![](https://img2018.cnblogs.com/blog/1449975/201901/1449975-20190104213122533-1904218420.png)

### 全局区
用于存放**全局变量和静态变量**，里面细分有一个常量区，字符串常量和其他常量也存放在此。该区域是在程序结束后由操作系统释放。

#### 变量和全局区

以下代码，在main函数创建p, q两个指针

调用getstr1函数，该函数在全局区创建字符串常量"test"，返回地址

调用getstr2函数，在全局区发现"test"常量被创建了，返回地址

虽然调用的是不同的函数，但是地址是一样的
```cpp
char* getstr1()
{
	char* p = (char*)"test";

	return p;
}

char* getstr2()
{
	char* q = (char*)"test";

	return q;
}

int main()
{
	char* p = NULL;
	char* q = NULL;

	p = getstr1();
	printf("p = %s, p = %d\n", p, p);

	q = getstr2();
	printf("q = %s, q = %d\n", q, q);
	return 0;
}
```

![](https://img-blog.csdn.net/20180402223156941)

#### static静态常量
使用static修饰符定义变量，相当于在全局区创建一份字符串常量，复制给变量名

即使在函数中定义，调用之后变量名被释放，全局区的字串不会被释放空间

### 栈区

由编译器自动分配释放，存放函数的形参、局部变量等。当函数执行完毕时自动释放。

#### 变量与栈的关系

以下代码，在主函数创建指针buf1，字符串数组buf2

调用getstr函数，先在全局区创建常量"test"，然后在栈区创建字符串数组str[]，然后将变量拷贝到str[]

当getstr函数运行完毕，数组str[]内存自动释放，空间内容未知，导致主函数buf内容可能是乱码
```cpp
char* getstr()
{
	char str[] = "test";//"test"存放在栈区
	return str;
}

int main()
{
	char* buf1 = NULL;
	char buf2[] = { 0 };
	buf1 = getstr();			//str[]释放之后，指针指向的地址内容未知，导致乱码
	strcpy(buf2, getstr());		//可能是先调用strcpy给buf2赋值，然后再释放str[]
	printf("buf = %s\n", buf1);
	printf("buf = %s\n", buf2);
	return 0;
}
```

![](https://img-blog.csdn.net/20180402214955401)

#### 调用函数和栈的关系
递归调用模型遵循栈的先进后出，后进先出。

### 堆区
一般由程序员手动分配释放（动态内存申请与释放），若程序员不释放，程序结束时可能由操作系统回收。

---

在堆区开辟sizeof(char*) * 100的内存，分配给temp

在全局区创建常量"test"，拷贝到temp指向的内存

将temp的地址返回给buf1

```cpp
char* getstr()
{
	//在堆区开辟sizeof(char*) * 100的内存，分配给temp
	char* temp = (char*)malloc(sizeof(char*) * 100);
	if (temp == NULL)
	{
		return NULL;
	}
	strcpy(temp, "test");
	return temp;
}

int main()
{
	char* buf1 = NULL;
	buf1 = getstr();
	if (buf1 != NULL)
	{
		printf("buf = %s\n", buf1);
		free(buf1);
		buf1 = NULL; 
	}
	return 0;
}
```

![](https://img-blog.csdn.net/20180402221307220)

### 代码区
存放函数体的二进制代码，由操作系统管理

- 存放CPU执行的机器指令
- 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是只读的，使其只读的原因是防止程序意外修改了他的指令

## new操作符
利用{{< highlight >}}new{{< /highlight >}}操作符在堆区开辟内存，同C语言的malloc函数

堆区开辟的内存，由用户手动开辟，手动释放，释放用{{< highlight >}}delete{{< /highlight >}}，同free函数

语法：new 数据类型，delete 指针

利用new创建的数据，会返回该数据对应类型的指针

```cpp
new int(10);        //创建一块内存，值是10
new int[10];        //创建一块连续内存，数组长度是10
```