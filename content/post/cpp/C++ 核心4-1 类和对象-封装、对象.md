---
title: C++ 核心4-1 类和对象-封装、对象
tags: ["C++", "编程学习"]
categories: ["C++"]
date: "2020-11-16 20:06:55"
toc: true
---


# 1 类和对象
面向对象三大特性：封装、继承、多态

## 1.1 封装
### 1.1.1 封装的意义
封装的意义：
- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

为了保证封装性，通常将成员变量性设置成私有，然后用get、set方法修改获取，可以在方法里做一些判断，比直接修改成员变量更好
```cpp
class Circle
{
private:
	double r;
public:
	double getS()
	{
		double r = getR();
		return 3.14 * r * r;
	}

	double getC()
	{
		double r = getR();
		return 3.14 * r * 2;
	}

	double getR()
	{
		return this->r;
	}

	void setR(double r)
	{
		this->r = r;
	}
};
```

### 1.1.2 访问权限
不写修饰符默认是私有权限

三种权限：
- public 公共权限

成员在类内可以访问，在类外也能访问

- protected 保护权限

成员在类内可以访问，在类外不能访问

继承中子类可以访问父类的保护权限的成员

- private 私有权限

成员在类内可以访问，在类外不能访问

继承中子类不能访问父类的私有权限的成员

### 1.1.3 struct和class的区别
- struct默认权限是共有
- class默认权限是私有

### 1.1.4 成员属性设为私有
为了保证封装性，通常将成员变量性设置成私有，然后用get、set方法修改获取，可以在方法里做一些判断，比直接修改成员变量更好

可以自己控制成员变量读写，以及输入数据正确性
```cpp
void setR(double r)
{
	if(r < 0)
	    reutrn;
	this->r = r;
}
```

## 1.2 对象的初始化和清理
### 1.2.1 构造函数和析构函数
- 构造函数：主要作用在于创建对象时为对象的成员变量赋值，构造函数由编译器自动调用，无需手动调用
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作

---

构造函数语法：类名(可以写参数){}
- 构造函数没有返回值也不用写void
- 函数名称和类名相同
- 构造函数可以有参数，可以重载
- 程序调用对象时自动调用，只会调用一次

析构函数语法：~类名(){}
- 析构函数，没有返回值不用写void
- 函数名称和类名相同，名称前加波浪符~
- 析构函数不可以有参数，不能重载
- 程序销毁对象时自动调用，只会调用一次

### 1.2.2 构造函数的分类及调用
分类：
- 按参数分为：有参构造和无参构造
```cpp
	Circle()	//构造
	{
		cout << "构造函数！" << endl;
	}
	
	Circle(int a)	//构造
	{
		cout << "构造函数！" << endl;
	}
```

- 按类型分为：普通构造和拷贝构造
```cpp
	Circle(const Circle& p)	    //拷贝构造
	{
		r = p.r;
	}
```

调用：
- 括号法
调用无参构造的时候不要加()，会被编译器认为是函数声明
```cpp
Circle c();     //错误
Circle c1;      //无参构造函数
Circle c2(5);   //有参
Circle c3(c2);  //拷贝构造
```
- 显示法

注意事项：

1. 匿名函数创建完会立刻销毁
2. 不要用拷贝构造函数创建匿名对象，编译器会认为你在声明对象

```cpp
Circle(5);              //匿名对象
Circle c1 = Circle();   //无参
```

- 隐式转换法
```cpp
Circle c1 = 5;      //调用有参构造
Circle c2 = c1;     //拷贝
```

### 1.2.3 拷贝构造函数的调用时机
- 使用一个创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 值方式返回局部对象

### 1.2.4 构造函数调用规则
构造函数调用规则：
- 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

### {{< highlight >}}1.2.5 深拷贝和浅拷贝{{< /highlight >}}
- 浅拷贝：简单的赋值拷贝操作

编译器默认使用赋值的拷贝构造

如果两个对象都有指针变量，调用拷贝构造的时候，两个对象的指针变量会指向同一块堆区内存，一个对象对内存操作，另一个也会变化

![](https://img2018.cnblogs.com/blog/774371/201907/774371-20190716091842178-448859259.jpg)

- 深拷贝：在堆区申请空间，再进行拷贝

如果两个对象都有指针变量，调用拷贝构造的时候，两个对象的指针变量会指向各自的堆区内存，一个对象对内存操作，另一个不会变化

解决方法：自己实现拷贝构造函数，在拷贝构造中创建堆区内存

![](https://img2018.cnblogs.com/blog/774371/201907/774371-20190716092012374-350888378.jpg)

### 1.2.6 初始化列表
语法：构造函数（形参列表）：成员变量1（值1），成员变量2（值2）...{ }

初始化列表构造函数
```cpp
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c)
	{

	}
```

传统构造函数
```cpp
	Person(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}
```

### 1.2.7 类对象作为类成员
程序执行顺序：栈的进出顺序

先在Person定义Phone类型变量 -> 走Phone类的构造 -> 走Person类构造 -> 走Person类析构 -> 走Phone类析构

```cpp
class Phone
{
public:
	Phone()
	{
		cout << "Phone!" << endl;
	}
	~Phone()
	{
		cout << "~Phone!" << endl;
	}
};

class Person
{
public:
	Phone phone;

	Person()
	{
		cout << "Person!" << endl;
	}

	~Person()
	{
		cout << "~Person!" << endl;
	}

};

int main()
{
	Person a;
	return 0;
}
```

结果：
```cpp
Phone!
Person!
~Person!
~Phone!
```

### 1.2.8 静态成员

- 静态成员变量
    - 所有对象共享同一份数据
    - 在编译阶段分配内存
    - 类内声明，类外初始化
- 静态成员函数
    - 所有对象共享同一个函数
    - 静态成员函数只能访问静态成员变量

## 1.3 C++对象模型和this指针
### 1.3.1 成员变量和成员函数分开存储
在C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类对象


//空对象占用内存为1

//C++编译器给每个空对象分配一个字节空间，为了区分空对象占内存的位置。
```cpp
class Empty
{};
cout << "sizeof Empty = " << sizeof(Empty) << endl;
```

//占用内存为4

//只算int A的大小，大小是4

静态成员存储在全局区，不算在对象大小。

函数不算在对象大小
```cpp
class Empty
{
    int A;          //非静态成员变量，属于类的对象
    static int B;   //静态成员变量，不属于类对象
    void func1(){}   //非静态成员函数，不属于类对象
    static void func2(){}    //静态成员函数，不属于类对象
};
cout << "sizeof Empty = " << sizeof(Empty) << endl;
```

### 1.3.2 this指针
this指针指向被调用的成员函数所属的对象

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途
- 当形参和成员变量同名时，可以用this指针区分
```cpp
int age;
Person(int age)
{
    this -> age = age;
}
```

- 在类的非静态成员函数中返回对象本身，可以使用return *this
```cpp
Person& test()
{
    return *this;   //返回本身对象
}
```
### 1.3.3 空指针访问成员函数
```cpp
class Person
{
    int age;
    int getAge()
    {
        return age;
    }
};

Person *p = NULL;
p.getAge();     //报错
```
对象执行getAge方法的时候，return age其实是return this->age，因为是空指针调用这个方法，所以this是空，所以报错

### 1.3.4 const修饰成员函数
常函数：
- 成员函数后加const成为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中可以修改

常对象：
- 声明对象前加const成为常对象
- 常对象只能调用常函数

