---
title: C++ 核心4-3 继承、多态、文件操作
tags: ["C++", "编程学习"]
categories: ["C++"]
date: "2020-12-20 16:18:55"
toc: true
---


# 1 继承

## 1.1 基本语法
**{{< highlight >}}基本语法：class 子类 : 继承方式（public, protected, private） 父类{{< /highlight >}}**

子类又称派生类，父类又称基类

## 1.2 继承方式
三种继承方式：
- public
    - 基类中所有 public 成员在派生类中为 public 属性；
    - 基类中所有 protected 成员在派生类中为 protected 属性；
    - 基类中所有 private 成员在派生类中不能使用。

- protected
    - 基类中的所有 public 成员在派生类中为 protected 属性；
    - 基类中的所有 protected 成员在派生类中为 protected 属性；
    - 基类中的所有 private 成员在派生类中不能使用。

- private
    - 基类中的所有 public 成员在派生类中均为 private 属性；
    - 基类中的所有 protected 成员在派生类中均为 private 属性；
    - 基类中的所有 private 成员在派生类中不能使用。

继承方式/基类成员|public成员|protected成员|private成员
|-|-|-|-|
public继承|public|protected|不可见
protected继承|protected|protected|不可见
private继承|private|private|不可见

**{{< highlight >}}总结：public继承所有权限不变；protected继承除了父类私有，其他所有变成protected权限；private继承除了父类私有，其他所有变成private权限。常用public继承。{{< /highlight >}}**

## 1.3 继承中的对象模型
父类中所有非静态成员属性都会被子类继承

私有成员属性也会被继承，但不能直接访问

## 1.4 继承中构造和析构顺序
先构造父类，在构造子类

先析构子类，再析构父类

## 1.5 继承同名成员处理
**{{< highlight >}}静态成员同理{{< /highlight >}}**

```cpp
class Base
{
    int a;
    void fun();
}
class Son :public Base
{
    int a;
    void fun();
}

Son s;
```

- 访问子类同名成员，直接访问
```cpp
cout << s.a;
cout << s.fun();
```

- 访问父类同名成员，加作用域
```cpp
cout << s.Base::a;
cout << s.Base::fun();
```

{{< highlight >}}如果子类出现和父类同名的函数，子类会将父类所有同名函数（包括重载）隐藏，如需访问要加作用域{{< /highlight >}}

## 1.6 多继承
> https://blog.csdn.net/liujiayu2/article/details/50925300

语法：class 子类 : 继承方式 父类1, 继承方式 父类2...

## 1.7 菱形继承
两个派生类同时继承一个基类，又有一个类同时继承两个派生类。

![](https://images2018.cnblogs.com/blog/1206020/201809/1206020-20180913153302636-745376035.png)

虚继承
> http://c.biancheng.net/view/2280.html

# 2 多态
## 2.1 基本概念
- 静态多态：函数重载、运算符重载
- 动态多态：派生类、虚继承

区别：
- 静态多态的函数地址早绑定：编译阶段确认函数地址
- 动态多态的函数地址晚绑定：运行阶段确认函数地址

```cpp
class Animal
{
    virtual void speak();
}

class Cat
{
    void speak();
}

//动态多态，派生类当参数调用各自的函数，而不是调用父类函数
//产生原因：函数地址绑定早晚
void doSpeak(Animal &animal)
{
    animal.speak();
}
```
动态多态满足条件：
1. 有继承关系
2. 子类要重写（override）父类方法

动态多态使用：
1. 父类的指针或引用，执行子类对象
2. 父类函数加virtual关键字，访问派生类中同名覆盖成员函数。

概念：
vfptr：虚函数指针，虚函数表指针

## 2.2 纯虚函数和抽象类
纯虚函数语法：virtual void fun() = 0;

只要有一个纯虚函数的类称为抽象类

特点：
1. 无法实例化对象
2. 抽象类的子类必须重写父类的纯虚函数，不然也算抽象类

## 2.3 虚析构和纯虚析构
### 2.3.1 虚析构

问题：

当用父类指针指向子类对象的时候，如果要删除父类指针，指针会调用父类析构，而不会调用子类析构。
```cpp
Animal animal = new Cat();
delete animal；
```

解决方法：

将父类析构加上virtual关键字，变成虚析构，就可以用父类指针释放子类对象

### 2.3.2 纯虚析构
类似抽象类，需要将纯虚析构重写（overwrite
```cpp
virtual ~Animal() = 0;
```

# 3 文件操作
C++文件操作要用头文件<fstream>

操作文件三大{{< highlight >}}类{{< /highlight >}}：
1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作

## 3.1 文本文件  
### 3.1.1 写文件
步骤：
1. 包含头文件：#include <fstream>
2. 创建流对象：ofstream ofs;
3. 打开文件：ofs.open("文件路径", 打开方式);
4. 写数据：ofs << "数据";
5. 关闭文件：ofs.close();

打开方式（常用）：
|打开方式|作用|
|-|-|
|ios::in|读文件|
|ios::out|写文件|
|ios::binary|二进制方式操作文件|
|打开方式|作用|

打开方式可以配合使用：ios::in | ios::binary

### 3.1.2 读文件
和写文件步骤一样

读文件在打开文件的时候要判断文件是否存在
```cpp
ifs.open("...",ios::in);
if(!ifs.is_open())
```

读取方式：
1. while(ifs >> buf)
2. while(ifs.getline(buf, sizeof(buf)))

## 3.2 二进制文件
指定打开方式：ios::binary

### 3.2.1 写文件
ofs.write((const char *)buf, sizeof(buf))

### 3.2.2 读文件
ofs.read((char *)buf, sizeof(buf))
