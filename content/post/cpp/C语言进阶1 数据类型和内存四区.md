---
author : "RealHath"
title: "C语言进阶1 数据类型和内存四区"
tags: ["C语言", "C++"]
categories: ["C++"]
date: "2020-11-14 15:15:03"
toc: true
---

## 头文件编写模板
### 防止头文件重复包含
1. #pragma once 只编译一次

好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。

缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。

不支持跨平台！

```cpp
//防止头文件重复包含
#pragma once
```

2. #ifndef  条件编译

缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况

兼容性高

```cpp
#ifndef 1
#define 1
    代码区
#endif // !1
```

### 兼容C++编译器
如果是C++编译器，按C标准编译

```cpp
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
    代码区
#ifdef __cplusplus
}
#endif // __cplusplus
```

## 数据类型
变量的本质：**固定内存块**的别名

### 数组地址
```cpp
int a[] = { 1,2,3,4,5,6,7 };
printf("size = %d\n", sizeof(a));   //数组大小
printf("a = %d  ", a);              //数组首元素地址
printf("&a = %d\n", &a);            //整个数组的首地址
printf("a+1 = %d  ", a + 1);        //数组首元素地址+1等于跳到首元素尾的地址
printf("&a+1 = %d\n", &a + 1);      //整个数组的首地址+1等于跳到数组尾的地址
```
结果
```cpp
size = 28
a = 9435804  &a = 9435804
a+1 = 9435808  &a+1 = 9435832
```

### typedef
给变量类型起别名

多和结构体一起使用

```cpp
typedef 变量类型 别名;
```

### void 类型
- 函数参数为空，定义函数时，可以用void修饰：int fun(void)
- 函数没有返回值：void fun(void)
- 不能定义void类型的普通变量：void a;//error，无法确定类型，不同类型分配空间不同
- 可以定义void *指针变量：void *p;//在32位程序指针永远是4字节
- void *p万能指针，常做函数返回值，函数参数

## 内存四区
> https://blog.csdn.net/helloyurenjie/article/details/79795059

![](https://img2018.cnblogs.com/blog/1449975/201901/1449975-20190104213122533-1904218420.png)

### 全局区
用于存放**全局变量和静态变量**，里面细分有一个常量区，字符串常量和其他常量也存放在此。该区域是在程序结束后由操作系统释放。

#### 变量和全局区

以下代码，在main函数创建p, q两个指针

调用getstr1函数，该函数在全局区创建字符串常量"test"，返回地址

调用getstr2函数，在全局区发现"test"常量被创建了，返回地址

虽然调用的是不同的函数，但是地址是一样的
```cpp
char* getstr1()
{
	char* p = (char*)"test";

	return p;
}

char* getstr2()
{
	char* q = (char*)"test";

	return q;
}

int main()
{
	char* p = NULL;
	char* q = NULL;

	p = getstr1();
	printf("p = %s, p = %d\n", p, p);

	q = getstr2();
	printf("q = %s, q = %d\n", q, q);
	return 0;
}
```

![](https://img-blog.csdn.net/20180402223156941)

#### static静态常量
使用static修饰符定义变量，相当于在全局区创建一份字符串常量，复制给变量名

即使在函数中定义，调用之后变量名被释放，全局区的字串不会被释放空间

### 栈区

由编译器自动分配释放，存放函数的形参、局部变量等。当函数执行完毕时自动释放。

#### 变量与栈的关系

以下代码，在主函数创建指针buf1，字符串数组buf2

调用getstr函数，先在全局区创建常量"test"，然后在栈区创建字符串数组str[]，然后将变量拷贝到str[]

当getstr函数运行完毕，数组str[]内存自动释放，空间内容未知，导致主函数buf内容可能是乱码
```cpp
char* getstr()
{
	char str[] = "test";//"test"存放在栈区
	return str;
}

int main()
{
	char* buf1 = NULL;
	char buf2[] = { 0 };
	buf1 = getstr();			//str[]释放之后，指针指向的地址内容未知，导致乱码
	strcpy(buf2, getstr());		//可能是先调用strcpy给buf2赋值，然后再释放str[]
	printf("buf = %s\n", buf1);
	printf("buf = %s\n", buf2);
	return 0;
}
```

![](https://img-blog.csdn.net/20180402214955401)

#### 调用函数和栈的关系
递归调用模型遵循栈的先进后出，后进先出。

### 堆区
一般由程序员手动分配释放（动态内存申请与释放），若程序员不释放，程序结束时可能由操作系统回收。

---

在堆区开辟sizeof(char*) * 100的内存，分配给temp

在全局区创建常量"test"，拷贝到temp指向的内存

将temp的地址返回给buf1

```cpp
char* getstr()
{
	//在堆区开辟sizeof(char*) * 100的内存，分配给temp
	char* temp = (char*)malloc(sizeof(char*) * 100);
	if (temp == NULL)
	{
		return NULL;
	}
	strcpy(temp, "test");
	return temp;
}

int main()
{
	char* buf1 = NULL;
	buf1 = getstr();
	if (buf1 != NULL)
	{
		printf("buf = %s\n", buf1);
		free(buf1);
		buf1 = NULL; 
	}
	return 0;
}
```

![](https://img-blog.csdn.net/20180402221307220)

## 技巧
### 求非字符串长度

字符串求长度有strlen()函数，其他类型没有

如果数组长度大于已用空间，则无法测出数组真实已使用的大小

```cpp
n = sizeof(a) / sizeof(int)     //数组的size / 数组元素类型的size
```

如果直接调用sizeof，a[]数组测试的大小应该是数组类型乘以数组长度
```cpp
int a[] = { 1,2,3,4,5,6,7 };
printf("size = %d", sizeof(a));     //数组的大小
```

如果a[]数组作为形参传递，a[]数组会退化为指针*a，相当于传递的是数组首元素地址，使用sizeof测试的结果为 *a指针类型的大小。
```cpp
int a[] = { 1,2,3,4,5,6,7 };
test(a);
void test(int a[])                      //退化为指针
{
	printf("size = %d", sizeof(a));     //指针类型的大小
}
```
