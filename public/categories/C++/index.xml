<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on RealHath的博客</title>
    <link>https://realhath.github.io/categories/C&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on RealHath的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 30 Sep 2021 22:10:55 +0000</lastBuildDate><atom:link href="https://realhath.github.io/categories/C++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>STL容器源码解析</title>
      <link>https://realhath.github.io/post/cpp11/STL%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 30 Sep 2021 22:10:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/STL%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description>1 STL基础 1.1 头文件 1 2 3 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;functional&amp;gt; using namespace std; cppreference.com 1.2 STL六大部件 容器（container） 分配器（Allocator） 算法（Algorithm） 迭代器（iterator） 适配器（adapter） 仿函数（functor） 1.3 容器分类 序列式容器（sequence） 关联式容器（associat</description>
    </item>
    
    <item>
      <title>nullptr、shared_ptr、unique_ptr、weak_ptr</title>
      <link>https://realhath.github.io/post/cpp11/nullptrshared_ptrunique_ptrweak_ptr/</link>
      <pubDate>Sun, 28 Mar 2021 13:42:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/nullptrshared_ptrunique_ptrweak_ptr/</guid>
      <description>1 nullptr C++98/03用的是 int* p = NULL NULL是#define NULL 0 nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。 2 智能指针 C++ 智能指针底层是采用引用计数的方式实现的。 简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1</description>
    </item>
    
    <item>
      <title>右值引用、移动构造</title>
      <link>https://realhath.github.io/post/cpp11/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Sun, 28 Mar 2021 13:17:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0/</guid>
      <description>1 右值引用 左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是&amp;quot;left value&amp;quot;、&amp;ldquo;right value&amp;rdquo; 的缩写，其实不然。lvalue 是“locator value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）</description>
    </item>
    
    <item>
      <title>for循环、constexpr修饰符、long long</title>
      <link>https://realhath.github.io/post/cpp11/for%E5%BE%AA%E7%8E%AFconstexpr%E4%BF%AE%E9%A5%B0%E7%AC%A6long-long/</link>
      <pubDate>Sun, 28 Mar 2021 10:43:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/for%E5%BE%AA%E7%8E%AFconstexpr%E4%BF%AE%E9%A5%B0%E7%AC%A6long-long/</guid>
      <description>1 for 1 2 3 for(表达式 1; 表达式 2; 表达式 3){ //循环体 } 遍历序列的变量都表示的是当前序列中的各个元素。不是迭代器 1 2 3 for (declaration : expression){ //循环体 } 2 constexpr修饰符 验证是否为常量表达式 1 2 constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; //正确 修饰函数 1 2 3 4 5 constexpr int display(int x) { //可以添加 using 执行、typede</description>
    </item>
    
    <item>
      <title>using，lambda匿名函数，模板默认参数</title>
      <link>https://realhath.github.io/post/cpp11/usinglambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 27 Mar 2021 20:39:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/usinglambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</guid>
      <description>1 using定义别名 typedef不能定义模板 1 2 3 //错误 typedef std::map&amp;lt;std::string, int&amp;gt; map_int_t;// ... typedef std::map&amp;lt;std::string, std::string&amp;gt; map_str_t;// ... 1.1 语法 定义模板 1 2 3 4 5 6 7 8 // 重定义unsigned int typedef unsigned int uint_t; using uint_t = unsigned int; // 重定义std::map typedef std::map&amp;lt;std::string, int&amp;gt; map_int_t; using map_int_t = std::map&amp;lt;std::string, int&amp;gt;; 2 lambda匿名函数 语法 1 2 3 4 [外部变量访问方式说明符] (参数) [mutable] [noexcept/throw()] -&amp;gt; 返回值类型</description>
    </item>
    
    <item>
      <title>auto类型推导、decltype类型推导、返回值类型后置</title>
      <link>https://realhath.github.io/post/cpp11/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BCdecltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/</link>
      <pubDate>Sat, 27 Mar 2021 19:55:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp11/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BCdecltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/</guid>
      <description>1 auto类型推导 auto自动类型推导，编译器在编译时确定变量类型 1.1 语法规则 1 auto name = value; 注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。 1.2 auto高级用法 1 2 3 4 5 int x = 0; auto *p1 = &amp;amp;x; //p1</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL3：set、map、STL函数对象</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-STL3setmapSTL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 13 Mar 2021 16:03:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-STL3setmapSTL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</guid>
      <description>1 set容器 1.1 set基本概念 所有元素会在插入时自动排序 set的底层使用二叉树实现的 set不允许容器有重复元素，multiset允许容器由重复元素 1.2 set构造和赋值 set set;//默认构造 set(const set&amp;amp; set);//拷贝构造 set&amp;amp; operator=(const set&amp;amp; set);//等号赋值 1.3 set大小和交换 size() empty() set1.swap(set2); 1.4 set插入和删除</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL2：stack、queue、list</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-STL2stackqueuelist/</link>
      <pubDate>Sat, 13 Mar 2021 09:32:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-STL2stackqueuelist/</guid>
      <description>1 stack容器 先进后出，后进先出 1.1 stack常用接口 stack stk;//默认构造 stack(const stack &amp;amp;stk);//拷贝构造 stack&amp;amp; operator=(const stack &amp;amp;stk);//等号赋值 push(elem);//压栈 pop();//出栈 top();//返回栈顶元素 empty();//判断是否为空 size();//返</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL1：vector、string、deque</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-STL1vectorstringdeque/</link>
      <pubDate>Wed, 10 Mar 2021 16:58:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-STL1vectorstringdeque/</guid>
      <description>STL六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器 容器 各种数据结构，如Vector、List、Map，用于存放数据。 算法 各种常见算法如：排序、增删查等。从实现来看，STL算法属于泛型函数。 迭代器 很惊奇，迭代器不属于容器，也不属于算法。 扮演起容器与算法之间的“粘合剂”，</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 模板</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 08 Mar 2021 09:07:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A8%A1%E6%9D%BF/</guid>
      <description>1 模板 1.1 基本语法 自动类型推导 1 2 3 4 5 6 7 template&amp;lt;typename T&amp;gt; //声明一个模板，告诉编译器通用数据类型T void mySwap(T &amp;amp;a, T &amp;amp;b) { T temp = a; a = b; b = temp; } 显示指定类型 1 mySwap&amp;lt;int&amp;gt;(a,b); 1.2 普通函数和函数模板的区别 普通函数调用可以发生隐式类型转换 函数模板用自动类型推导，不可以发生隐式类型转换 1 void mySwap(T &amp;amp;a, T &amp;amp;b) 函数模板用显示指定类型，可</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心4-3 继承、多态、文件操作</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-3-%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 20 Dec 2020 16:18:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-3-%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1 继承 1.1 基本语法 基本语法：class 子类 : 继承方式（public, protected, private） 父类 子类又称派生类，父类又称基类 1.2 继承方式 三种继承方式： public 基类中所有 public 成员在派生类中为 public 属性； 基类中所有 protected 成员在派生类中为 protected 属性； 基类中所有 private 成员在派生类中不能使用。 protected 基类中的所有 public 成员在派生类中</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心4-2 友元、运算符重载</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-2-%E5%8F%8B%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Mon, 14 Dec 2020 19:48:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-2-%E5%8F%8B%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <description>1 友元 私有属性能让类外一些函数或者类访问，用到友元 友元关键字friend 友元三种实现 全局函数做友元 1 2 3 4 class Person { friend void test(); //全局函数做友元 }; 类做友元 1 2 3 4 class Person { friend class People; //类做友元 }; 成员函数做友元 1 2 3 4 class Person { friend void People::test(); //别的类的成员函数做友元 }; 2 运算符重载 运算符重载不会影响运算符本</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心4-1 类和对象-封装、对象</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 16 Nov 2020 20:06:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%834-1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1/</guid>
      <description>1 类和对象 面向对象三大特性：封装、继承、多态 1.1 封装 1.1.1 封装的意义 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 为了保证封装性，通常将成员变量性设置成私有，然后用get、set方法修改获取，可以在方法里做一些判断，比直接修改成员变量更好 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心3 函数提高</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%833-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98/</link>
      <pubDate>Sun, 15 Nov 2020 20:35:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%833-%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98/</guid>
      <description>1 函数提高 1.1 函数默认参数 注意 如果某个位置已经有默认参数，在这个位置往后都要有默认值 1 2 3 int fun(int a, int b = 1, int c = 2); fun(10); //调用的时候能少传参数 如果函数声明有默认参数，函数实现就不能有默认参数 声明和实现只能有一个带默认参数 1 2 3 4 5 6 int fun(int a = 10, int b = 10); //声明 int fun(int a = 10, int b = 10) //实现，</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心2 引用</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%832-%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sat, 14 Nov 2020 16:54:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%832-%E5%BC%95%E7%94%A8/</guid>
      <description>1 引用 https://www.runoob.com/cplusplus/cpp-references.html https://www.cnblogs.com/zhxmdefj/p/11185124.html 作用：给变量取别名，同一块内存不同变量名 语法：数据类型 &amp;amp;别名 = 原名 1.1 与指针的区别 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初</description>
    </item>
    
    <item>
      <title>C语言进阶1 数据类型和内存四区</title>
      <link>https://realhath.github.io/post/cpp/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B61-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/</link>
      <pubDate>Sat, 14 Nov 2020 15:15:03 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B61-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/</guid>
      <description>1 头文件编写模板 1.1 防止头文件重复包含 #pragma once 只编译一次 好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。 缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。 不支持跨平台！ 1 2 //防止头文件重复包含 #pragma once #ifndef 条件编译 缺</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 核心1 内存模型</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%831-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 14 Nov 2020 15:12:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E6%A0%B8%E5%BF%831-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>1 内存四区 https://blog.csdn.net/helloyurenjie/article/details/79795059 1.1 全局区 用于存放全局变量和静态变量，里面细分有一个常量区，字符串常量和其他常量也存放在此。该区域是在程序结束后由操作系统释放。 1.1.1 变量和全局区 以下代码，在main函数创建p, q两个指针 调用getstr1函数，该函数在全局区创建字符串常量&amp;quot;test&amp;quot;，</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础4 结构体</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%804-%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Fri, 13 Nov 2020 20:46:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%804-%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>1 结构体基本概念 结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 2 结构体定义和使用 三种方式： struct 结构体名 变量名; struct 结构体名 变量名 = { 成员变量 }; 定义结构体顺便创建变量 3 结构体指针 利用操作符-&amp;gt;访问指针指向的结构体属性 作用 用指针更灵活 减少内存空间 4 结构体做函数参数 值传递</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础3 指针</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%803-%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 13 Nov 2020 20:12:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%803-%E6%8C%87%E9%92%88/</guid>
      <description>文档：C语言进阶2 指针.md 链接：http://note.youdao.com/noteshare?id=74fbcd34c19e929993947507839a53d0&amp;amp;sub=49CF12A503D740C6BF98CCB88965FEFC 1 空指针 空指针：指针变量指向</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础2 流程控制、数组、函数</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%802-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 11 Nov 2020 20:20:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%802-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/</guid>
      <description>1 选择结构 1.1 if语句 和C一样 结构： 1 2 3 4 5 6 7 8 9 10 11 12 if () { } else if () { } else { } 1.2 switch语句 和C一样 结构： 1 2 3 4 5 switch(表达式) { case 结果1: break; defalut: break; } 2 循环结构 2.1 while循环 结构： 1 2 3 4 while(循环条件) { } 2.2 dowhile循环 先执行一次在做判断 结构 1 2 3</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础1 数据类型</title>
      <link>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%801-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 09 Nov 2020 20:27:55 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C&#43;&#43;-%E5%9F%BA%E7%A1%801-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1 常量 #define宏常量 1 2 #define 常量名 常量 #define DAY 7 //常量名尽量全部大写 const修饰符 1 2 const 数据类型 变量名 = 值 const int a = 10; 2 数据类型 1字节=8位，符号位占1位 用sizeof测量变量大小 多用size_t类型 https://blog.csdn.net/JIEJINQUANIL/article/details/50981834 2.1 整型 数据类型 空间 取值范围 short 2字节 -2^15 ~ 2^15-1 int 4字节 -2^31 ~ 2^31-1 long 4字节 -2^31 ~ 2^31-1 long long 8字</description>
    </item>
    
    <item>
      <title>C语言进阶1 指针</title>
      <link>https://realhath.github.io/post/cpp/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B62-%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 09 Nov 2020 20:25:14 +0000</pubDate>
      
      <guid>https://realhath.github.io/post/cpp/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B62-%E6%8C%87%E9%92%88/</guid>
      <description>1 指针变量 指针变量是指存放地址的变量。 给指针变量p赋值，只会改变指针变量值，不会改变所指向的内存的值 给指针变量*p赋值，不会改变指针变量值，只会改变所指向内存的值 如果指针指向字符常量，值不可改变 不允许向空指针或者非法地址拷贝内容 2 指针间接赋值 2.1 二级指针 二级指针:也叫双指针,指针的</description>
    </item>
    
  </channel>
</rss>
